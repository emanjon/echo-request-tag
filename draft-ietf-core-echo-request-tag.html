<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>CoAP: Echo, Request-Tag, and Token Processing</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 15px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Request Freshness">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Fragmented Message Body Integrity">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Request-Response Binding">
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 The Echo Option">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Option Format">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Echo Processing">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Applications">
<link href="#rfc.section.3" rel="Chapter" title="3 The Request-Tag Option">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Option Format">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Request-Tag Processing by Servers">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Setting the Request-Tag">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Applications">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 Body Integrity Based on Payload Integrity">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 Multiple Concurrent Blockwise Operations">
<link href="#rfc.section.3.4.3" rel="Chapter" title="3.4.3 Simplified Block-Wise Handling for Constrained Proxies">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Rationale for the Option Properties">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Rationale for Introducing the Option">
<link href="#rfc.section.4" rel="Chapter" title="4 Block2 / ETag Processing">
<link href="#rfc.section.5" rel="Chapter" title="5 Token Processing">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Privacy Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Methods for Generating Echo Option Values">
<link href="#rfc.appendix.B" rel="Chapter" title="B Request-Tag Message Size Impact">
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.19.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Amsuess, C., Mattsson, J., and G. Selander" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-core-echo-request-tag-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-02-25" />
  <meta name="dct.abstract" content="This document specifies security enhancements to the Constrained Application Protocol (CoAP). The Echo option and the Request-Tag option are useful for some use cases. The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its apparent network address. The Request-Tag option allows the CoAP server to match Block-Wise message fragments belonging to the same request. The document also updates the CoAP Token processing requirements to ensure secure binding of responses to requests when CoAP is used with DTLS." />
  <meta name="description" content="This document specifies security enhancements to the Constrained Application Protocol (CoAP). The Echo option and the Request-Tag option are useful for some use cases. The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its apparent network address. The Request-Tag option allows the CoAP server to match Block-Wise message fragments belonging to the same request. The document also updates the CoAP Token processing requirements to ensure secure binding of responses to requests when CoAP is used with DTLS." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CoRE Working Group</td>
<td class="right">C. Amsuess</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Updates: 7252 (if approved)</td>
<td class="right">J. Mattsson</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">G. Selander</td>
</tr>
<tr>
<td class="left">Expires: August 29, 2019</td>
<td class="right">Ericsson AB</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 25, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">CoAP: Echo, Request-Tag, and Token Processing<br />
  <span class="filename">draft-ietf-core-echo-request-tag-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies security enhancements to the Constrained Application Protocol (CoAP). The Echo option and the Request-Tag option are useful for some use cases. The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its apparent network address. The Request-Tag option allows the CoAP server to match Block-Wise message fragments belonging to the same request. The document also updates the CoAP Token processing requirements to ensure secure binding of responses to requests when CoAP is used with DTLS.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 29, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Request Freshness</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Fragmented Message Body Integrity</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Request-Response Binding</a>
</li>
<li>1.4.   <a href="#rfc.section.1.4">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">The Echo Option</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Option Format</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Echo Processing</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Applications</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">The Request-Tag Option</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Option Format</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Request-Tag Processing by Servers</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Setting the Request-Tag</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Applications</a>
</li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">Body Integrity Based on Payload Integrity</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">Multiple Concurrent Blockwise Operations</a>
</li>
<li>3.4.3.   <a href="#rfc.section.3.4.3">Simplified Block-Wise Handling for Constrained Proxies</a>
</li>
</ul><li>3.5.   <a href="#rfc.section.3.5">Rationale for the Option Properties</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Rationale for Introducing the Option</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Block2 / ETag Processing</a>
</li>
<li>5.   <a href="#rfc.section.5">Token Processing</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Privacy Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Methods for Generating Echo Option Values</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Request-Tag Message Size Impact</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a>
</li>
<li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The initial Constrained Application Protocol (CoAP) suite of specifications (<a href="#RFC7252" class="xref">[RFC7252]</a>, <a href="#RFC7641" class="xref">[RFC7641]</a>, and <a href="#RFC7959" class="xref">[RFC7959]</a>) was designed with the assumption that security could be provided on a separate layer, in particular by using DTLS (<a href="#RFC6347" class="xref">[RFC6347]</a>). However, for some use cases, additional functionality or extra processing is needed to support secure CoAP operations. This document specifies security enhancements to the Constrained Application Protocol (CoAP).</p>
<p id="rfc.section.1.p.2">This document specifies two server-oriented CoAP options, the Echo option and the Request-Tag option: The Echo option enables a CoAP server to verify the freshness of a request, synchronize state, or force a client to demonstrate reachability at its apparent network address. The Request-Tag option allows the CoAP server to match message fragments belonging to the same request, fragmented using the CoAP Block-Wise Transfer mechanism, which mitigates attacks and enables concurrent blockwise operations. These options in themselves do not replace the need for a security protocol; they specify the format and processing of data which, when integrity protected using e.g. DTLS (<a href="#RFC6347" class="xref">[RFC6347]</a>), TLS (<a href="#RFC8446" class="xref">[RFC8446]</a>), or OSCORE (<a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>), provide the additional security features.</p>
<p id="rfc.section.1.p.3">The document also updates the processing requirements on the Token. The updated processing ensures secure binding of responses to requests, thus mitigating error cases and attacks where the client may erroneously associate the wrong response to a request.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#req-fresh" id="req-fresh">Request Freshness</a>
</h1>
<p id="rfc.section.1.1.p.1">A CoAP server receiving a request is in general not able to verify when the request was sent by the CoAP client. This remains true even if the request was protected with a security protocol, such as DTLS. This makes CoAP requests vulnerable to certain delay attacks which are particularly incriminating in the case of actuators (<a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a>). Some attacks are possible to mitigate by establishing fresh session keys, e.g. performing a DTLS handshake for each actuation, but in general this is not a solution suitable for constrained environments, for example, due to increased message overhead and latency. Additionally, if there are proxies, fresh DTLS session keys between server and proxy does not say anything about when the client made the request. In a general hop-by-hop setting, freshness may need to be verified in each hop.</p>
<p id="rfc.section.1.1.p.2">A straightforward mitigation of potential delayed requests is that the CoAP server rejects a request the first time it appears and asks the CoAP client to prove that it intended to make the request at this point in time. The Echo option, defined in this document, specifies such a mechanism which thereby enables a CoAP server to verify the freshness of a request. This mechanism is not only important in the case of actuators, or other use cases where the CoAP operations require freshness of requests, but also in general for synchronizing state between CoAP client and server and to verify aliveness of the client.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#body-int" id="body-int">Fragmented Message Body Integrity</a>
</h1>
<p id="rfc.section.1.2.p.1">CoAP was designed to work over unreliable transports, such as UDP, and include a lightweight reliability feature to handle messages which are lost or arrive out of order. In order for a security protocol to support CoAP operations over unreliable transports, it must allow out-of-order delivery of messages using e.g. a sliding replay window such as described in Section 4.1.2.6 of DTLS (<a href="#RFC6347" class="xref">[RFC6347]</a>).</p>
<p id="rfc.section.1.2.p.2">The Block-Wise Transfer mechanism <a href="#RFC7959" class="xref">[RFC7959]</a> extends CoAP by defining the transfer of a large resource representation (CoAP message body) as a sequence of blocks (CoAP message payloads). The mechanism uses a pair of CoAP options, Block1 and Block2, pertaining to the request and response payload, respectively. The blockwise functionality does not support the detection of interchanged blocks between different message bodies to the same resource having the same block number. This remains true even when CoAP is used together with a security protocol such as DTLS or OSCORE, within the replay window (<a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a>), which is a vulnerability of CoAP when using RFC7959.</p>
<p id="rfc.section.1.2.p.3">A straightforward mitigation of mixing up blocks from different messages is to use unique identifiers for different message bodies, which would provide equivalent protection to the case where the complete body fits into a single payload. The ETag option <a href="#RFC7252" class="xref">[RFC7252]</a>, set by the CoAP server, identifies a response body fragmented using the Block2 option. This document defines the Request-Tag option for identifying the request body fragmented using the Block1 option, similar to ETag, but ephemeral and set by the CoAP client.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#req-resp-bind" id="req-resp-bind">Request-Response Binding</a>
</h1>
<p id="rfc.section.1.3.p.1">A fundamental requirement of secure REST operations is that the client can bind a response to a particular request. If this is not valid a client may erroneously associate the wrong response to a request. The wrong response may be an old response for the same resource or for a completely different resource (see e.g. Section 2.3 of <a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a>). For example a request for the alarm status &#8220;GET /status&#8221; may be associated to a prior response &#8220;on&#8221;, instead of the correct response &#8220;off&#8221;.</p>
<p id="rfc.section.1.3.p.2">In HTTPS, binding is assured by the ordered and reliable delivery as well as mandating that the server sends responses in the same order that the requests were received. The same is not true for CoAP where the server (or an attacker) can return responses in any order. Concurrent requests are instead differentiated by their Token. Note that the CoAP Message ID cannot be used for this purpose since those are typically different for REST request and corresponding response in case of &#8220;separate response&#8221;, see Section 2.2 of <a href="#RFC7252" class="xref">[RFC7252]</a>.</p>
<p id="rfc.section.1.3.p.3">Unfortunately, CoAP <a href="#RFC7252" class="xref">[RFC7252]</a> does not treat Token as a cryptographically important value and does not give stricter guidelines than that the tokens currently &#8220;in use&#8221; SHOULD (not SHALL) be unique. If used with security protocol not providing bindings between requests and responses (e.g. DTLS and TLS) token reuse may result in situations where a client matches a response to the wrong request. Note that mismatches can also happen for other reasons than a malicious attacker, e.g. delayed delivery or a server sending notifications to an uninterested client.</p>
<p id="rfc.section.1.3.p.4">A straightforward mitigation is to mandate clients to never reuse tokens until the AEAD keys have been replaced. As there may be any number of responses to a request (see e.g. <a href="#RFC7641" class="xref">[RFC7641]</a>), the easiest way to accomplish this is to implement the token as a counter and never reuse any tokens at all. This document updates the Token processing in <a href="#RFC7252" class="xref">[RFC7252]</a> to always assure a cryptographically secure binding of responses to requests.</p>
<h1 id="rfc.section.1.4">
<a href="#rfc.section.1.4">1.4.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.4.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.4.p.2">Unless otherwise specified, the terms &#8220;client&#8221; and &#8220;server&#8221; refers to &#8220;CoAP client&#8221; and &#8220;CoAP server&#8221;, respectively, as defined in <a href="#RFC7252" class="xref">[RFC7252]</a>. The term &#8220;origin server&#8221; is used as in <a href="#RFC7252" class="xref">[RFC7252]</a>. The term &#8220;origin client&#8221; is used in this document to denote the client from which a request originates; to distinguish from clients in proxies.</p>
<p id="rfc.section.1.4.p.3">The terms &#8220;payload&#8221; and &#8220;body&#8221; of a message are used as in <a href="#RFC7959" class="xref">[RFC7959]</a>.  The complete interchange of a request and a response body is called a (REST) &#8220;operation&#8221;. An operation fragmented using <a href="#RFC7959" class="xref">[RFC7959]</a> is called a &#8220;blockwise operation&#8221;. A blockwise operation which is fragmenting the request body is called a &#8220;blockwise request operation&#8221;.  A blockwise operation which is fragmenting the response body is called a &#8220;blockwise response operation&#8221;.</p>
<p id="rfc.section.1.4.p.4">Two request messages are said to be &#8220;matchable&#8221; if they occur between the same endpoint pair, have the same code and the same set of options except for elective NoCacheKey options and options involved in block-wise transfer (Block1, Block2 and Request-Tag).  Two operations are said to be matchable if any of their messages are.</p>
<p id="rfc.section.1.4.p.5">Two matchable blockwise operations are said to be &#8220;concurrent&#8221; if a block of the second request is exchanged even though the client still intends to exchange further blocks in the first operation. (Concurrent blockwise request operations are impossible with the options of <a href="#RFC7959" class="xref">[RFC7959]</a> because the second operation&#8217;s block overwrites any state of the first exchange.).</p>
<p id="rfc.section.1.4.p.6">The Echo and Request-Tag options are defined in this document.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#echo" id="echo">The Echo Option</a>
</h1>
<p id="rfc.section.2.p.1">The Echo option is a lightweight server-driven challenge-response mechanism for CoAP, motivated by the need for a server to verify freshness of a request as described in <a href="#req-fresh" class="xref">Section 1.1</a>. With request freshness we mean that the server can determine that the client (or in the case of hop-by-hop security the proxy) sent the request recently. The time threshold for being fresh is application specific. The Echo option value is a challenge from the server to the client included in a CoAP response and echoed back to the server in one or more CoAP requests.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#echo-format" id="echo-format">Option Format</a>
</h1>
<p id="rfc.section.2.1.p.1">The Echo Option is elective, safe-to-forward, not part of the cache-key, and not repeatable, see <a href="#echo-table" class="xref">Figure 1</a>, which extends Table 4 of <a href="#RFC7252" class="xref">[RFC7252]</a>).</p>
<div id="rfc.figure.1"></div>
<div id="echo-table"></div>
<pre>
+-----+---+---+---+---+-------------+--------+------+---------+---+---+
| No. | C | U | N | R | Name        | Format | Len. | Default | E | U |
+-----+---+---+---+---+-------------+--------+------+---------+---+---+
| TBD |   |   | x |   | Echo        | opaque | 4-40 | (none)  | x | x |
+-----+---+---+---+---+-------------+--------+------+---------+---+---+

      C = Critical, U = Unsafe, N = NoCacheKey, R = Repeatable,
      E = Encrypt and Integrity Protect (when using OSCORE)
</pre>
<p class="figure">Figure 1: Echo Option Summary</p>
<p id="rfc.section.2.1.p.2">[ Note to RFC editor: If this document is released before core-object-security, then the following paragraph and the &#8220;E&#8221;/&#8221;U&#8221; columns above need to move into core-object-security, as they are defined in that draft. ]</p>
<p id="rfc.section.2.1.p.3">The Echo option MAY be an Inner or Outer option <a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>, and the Inner and Outer values are independent. The Inner option is encrypted and integrity protected between the endpoints, whereas the Outer option is not protected by OSCORE and visible between the endpoints to the extent it is not protected by some other security protocol.  E.g. in the case of DTLS hop-by-hop between the endpoints, the Outer option is visible to proxies along the path.</p>
<p id="rfc.section.2.1.p.4">The Echo option value is generated by a server, and its content and structure are implementation specific. Different methods for generating Echo option values are outlined in <a href="#echo-state" class="xref">Appendix A</a>. Clients and intermediaries MUST treat an Echo option value as opaque and make no assumptions about its content or structure.</p>
<p id="rfc.section.2.1.p.5">When receiving an Echo option in a request, the server MUST be able to verify that the Echo option value was generated by the server as well as the point in time when the Echo option value was generated.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#echo-proc" id="echo-proc">Echo Processing</a>
</h1>
<p id="rfc.section.2.2.p.1">The Echo option MAY be included in any request or response (see <a href="#echo-app" class="xref">Section 2.3</a> for different applications), but the Echo option MUST NOT be used with empty CoAP requests (i.e. Code=0.00).</p>
<p id="rfc.section.2.2.p.2">If a server receives a request which has freshness requirements, the request does not contain a fresh Echo option value, and the server cannot verify the freshness of the request in some other way, the server MUST NOT process the request further and SHOULD send a 4.01 Unauthorized response with an Echo option. The server MAY include the same Echo option value in several different responses and to different clients.</p>
<p id="rfc.section.2.2.p.3">The application decides under what conditions a CoAP request to a resource is required to be fresh. These conditions can for example include what resource is requested, the request method and other data in the request, and conditions in the environment such as the state of the server or the time of the day.</p>
<p id="rfc.section.2.2.p.4">The server may use request freshness provided by the Echo option to verify the aliveness of a client or to synchronize state. The server may also include the Echo option in a response to force a client to demonstrate reachability at their apparent network address.</p>
<p id="rfc.section.2.2.p.5">Upon receiving a 4.01 Unauthorized response with the Echo option, the client SHOULD resend the original request with the addition of an Echo option with the received Echo option value. The client MAY send a different request compared to the original request. Upon receiving any other response with the Echo option, the client SHOULD echo the Echo option value in the next request to the server. The client MAY include the same Echo option value in several different requests to the server.</p>
<p id="rfc.section.2.2.p.6">Upon receiving a request with the Echo option, the server determines if the request has freshness requirements. If the request does not have freshness requirements, the Echo option MAY be ignored. If the request has freshness requirements and the server cannot verify the freshness of the request in some other way, the server MUST verify that the Echo option value was generated by the server; otherwise the request is not processed further. The server MUST then calculate the round-trip time RTT = (t1 - t0), where t1 is the request receive time and t0 is the time when the Echo option value was generated. The server MUST only accept requests with a round-trip time below a certain threshold T, i.e. RTT &lt; T. If the server cannot verify that the Echo option value was generated by the server or the round-trip time is not below the threshold the request is not processed further, and an error message MAY be sent. The error message SHOULD include a new Echo option. The threshold T is application specific, its value depends e.g. on the freshness requirements of the request. An example message flow is illustrated in <a href="#echo-figure" class="xref">Figure 2</a>.</p>
<div id="rfc.figure.2"></div>
<div id="echo-figure"></div>
<pre>
Client   Server
   |       |
   +------&gt;|        Code: 0.03 (PUT)
   |  PUT  |       Token: 0x41
   |       |    Uri-Path: lock
   |       |     Payload: 0 (Unlock)
   |       |
   |&lt;------+ t0     Code: 4.01 (Unauthorized)
   |  4.01 |       Token: 0x41
   |       |        Echo: 0x437468756c687521
   |       |
   +------&gt;| t1     Code: 0.03 (PUT)
   |  PUT  |       Token: 0x42
   |       |    Uri-Path: lock
   |       |        Echo: 0x437468756c687521
   |       |     Payload: 0 (Unlock)
   |       |
   |&lt;------+        Code: 2.04 (Changed)
   |  2.04 |       Token: 0x42
   |       |
</pre>
<p class="figure">Figure 2: Example Echo Option Message Flow</p>
<p id="rfc.section.2.2.p.7">Note that the server does not have to synchronize the time used for the Echo timestamps with any other party. However, if the server loses time continuity, e.g. due to reboot, it MUST reject all Echo values that was created before time continuity was lost.</p>
<p id="rfc.section.2.2.p.8">When used to serve freshness requirements (including client aliveness and state synchronizing), CoAP messages containing the Echo option MUST be integrity protected between the intended endpoints, e.g. using DTLS, TLS, or an OSCORE Inner option (<a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>). When used to demonstrate reachability at their apparent network address, the Echo option MAY be unprotected.</p>
<p id="rfc.section.2.2.p.9">A CoAP-to-CoAP proxy MAY respond to requests with 4.01 with an Echo option to ensure the client&#8217;s reachability at its apparent address, and MUST remove the Echo option it recognizes as one generated by itself on follow-up requests. However, it MUST relay the Echo option of responses unmodified, and MUST relay the Echo option of requests it does not recognize as generated by itself unmodified.</p>
<p id="rfc.section.2.2.p.10">The CoAP server side of CoAP-to-HTTP proxies MAY request freshness, especially if they have reason to assume that access may require it (e.g. because it is a PUT or POST); how this is determined is out of scope for this document. The CoAP client side of HTTP-to-CoAP proxies SHOULD respond to Echo challenges themselves if they know from the recent establishing of the connection that the HTTP request is fresh. Otherwise, they SHOULD respond with 503 Service Unavailable, Retry-After: 0 and terminate any underlying Keep-Alive connection. They MAY also use other mechanisms to establish freshness of the HTTP request that are not specified here.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#echo-app" id="echo-app">Applications</a>
</h1>
<p></p>

<ol>
<li>Actuation requests often require freshness guarantees to avoid accidental or malicious delayed actuator actions. In general, all non-safe methods (e.g. POST, PUT, DELETE) may require freshness guarantees for secure operation.  <ul>
<li>The same Echo value may be used for multiple actuation requests to the same server, as long as the total round-trip time since the Echo option value was generated is below the freshness threshold.</li>
<li>For actuator applications with low delay tolerance, to avoid additional round-trips for multiple requests in rapid sequence, the server may include the Echo option with a new value in response to a request containing the Echo option. The client then uses the Echo option with the new value in the next actuation request, and the server compares the receive time accordingly.</li>
</ul>
</li>
<li>A server may use the Echo option to synchronize state or time with a requesting client. A server MUST NOT synchronize state or time with clients which are not the authority of the property being synchronized. E.g. if access to a server resource is dependent on time, then the client MUST NOT set the time of the server.  <ul>
<li>If a server reboots during operation it may need to synchronize state or time before continuing the interaction. For example, with OSCORE it is possible to reuse a partly persistently stored security context by synchronizing the Partial IV (sequence number) using the Echo option, see Section 7.5 of <a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>.</li>
<li>A device joining a CoAP group communication <a href="#RFC7390" class="xref">[RFC7390]</a> protected with OSCORE <a href="#I-D.ietf-core-oscore-groupcomm" class="xref">[I-D.ietf-core-oscore-groupcomm]</a> may be required to initially verify freshness and synchronize state or time with a client by using the Echo option in a unicast response to a multicast request. The client receiving the response with the Echo option includes the Echo option with the same value in a request, either in a unicast request to the responding server, or in a subsequent group request. In the latter case, the Echo option will be ignored expect by responding server.</li>
</ul>
</li>
<li>A server that sends large responses to unauthenticated peers SHOULD mitigate amplification attacks such as described in Section 11.3 of <a href="#RFC7252" class="xref">[RFC7252]</a> (where an attacker would put a victim&#8217;s address in the source address of a CoAP request). For this purpose, a server MAY ask a client to Echo its request to verify its source address. This needs to be done only once per peer and limits the range of potential victims from the general Internet to endpoints that have been previously in contact with the server. For this application, the Echo option can be used in messages that are not integrity protected, for example during discovery.  <ul><li>In the presence of a proxy, a server will not be able to distiguish different origin client endpoints. Following from the recommendation above, a proxy that sends large responses to unauthenticatied peers SHOULD mitigate amplification attacks. The proxy MAY use Echo to verify origin reachability as described in <a href="#echo-proc" class="xref">Section 2.2</a>. The proxy MAY forward idempotent requests immediately to have a cached result available when the client&#8217;s Echoed request arrives.</li></ul>
</li>
<li>A server may want to use the request freshness provided by the Echo to verify the aliveness of a client. Note that in a deployment with hop-by-hop security and proxies, the server can only verify aliveness of the closest proxy.</li>
</ol>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#request-tag" id="request-tag">The Request-Tag Option</a>
</h1>
<p id="rfc.section.3.p.1">The Request-Tag is intended for use as a short-lived identifier for keeping apart distinct blockwise request operations on one resource from one client, addressing the issue described in <a href="#body-int" class="xref">Section 1.2</a>. It enables the receiving server to reliably assemble request payloads (blocks) to their message bodies, and, if it chooses to support it, to reliably process simultaneous blockwise request operations on a single resource. The requests must be integrity protected in order to protect against interchange of blocks between different message bodies.</p>
<p id="rfc.section.3.p.2">In essence, it is an implementation of the &#8220;proxy-safe elective option&#8221; used just to &#8220;vary the cache key&#8221; as suggested in <a href="#RFC7959" class="xref">[RFC7959]</a> Section 2.4.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#req-tag-format" id="req-tag-format">Option Format</a>
</h1>
<p id="rfc.section.3.1.p.1">The Request-Tag option is not critical, is safe to forward, repeatable, and part of the cache key, see <a href="#req-tag-table" class="xref">Figure 3</a>, which extends Table 4 of <a href="#RFC7252" class="xref">[RFC7252]</a>).</p>
<div id="rfc.figure.3"></div>
<div id="req-tag-table"></div>
<pre>
+-----+---+---+---+---+-------------+--------+------+---------+---+---+
| No. | C | U | N | R | Name        | Format | Len. | Default | E | U |
+-----+---+---+---+---+-------------+--------+------+---------+---+---+
| TBD |   |   |   | x | Request-Tag | opaque |  0-8 | (none)  | x | x |
+-----+---+---+---+---+-------------+--------+------+---------+---+---+

      C = Critical, U = Unsafe, N = NoCacheKey, R = Repeatable,
      E = Encrypt and Integrity Protect (when using OSCORE)
</pre>
<p class="figure">Figure 3: Request-Tag Option Summary</p>
<p id="rfc.section.3.1.p.2">[ Note to RFC editor: If this document is released before core-object-security, then the following paragraph and the &#8220;E&#8221;/&#8221;U&#8221; columns above need to move into core-object-security, as they are defined in that draft. ]</p>
<p id="rfc.section.3.1.p.3">Request-Tag, like the block options, is both a class E and a class U option in terms of OSCORE processing (see Section 4.1 of <a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>): The Request-Tag MAY be an inner or outer option. It influences the inner or outer block operation, respectively. The inner and outer values are therefore independent of each other. The inner option is encrypted and integrity protected between client and server, and provides message body identification in case of end-to-end fragmentation of requests. The outer option is visible to proxies and labels message bodies in case of hop-by-hop fragmentation of requests.</p>
<p id="rfc.section.3.1.p.4">The Request-Tag option is only used in the request messages of blockwise operations.</p>
<p id="rfc.section.3.1.p.5">The Request-Tag mechanism can be applied independently on the server and client sides of CoAP-to-CoAP proxies as are the block options, though given it is safe to forward, a proxy is free to just forward it when processing an operation.  CoAP-to-HTTP proxies and HTTP-to-CoAP proxies can use Request-Tag on their CoAP sides; it is not applicable to HTTP requests.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#request-tag-processing" id="request-tag-processing">Request-Tag Processing by Servers</a>
</h1>
<p id="rfc.section.3.2.p.1">The Request-Tag option does not require any particular processing on the server side outside of the processing already necessary for any unknown elective proxy-safe cache-key option: The option varies the properties that distinguish blockwise operations (which includes all options except elective NoCacheKey and except Block1/2), and thus the server can not treat messages with a different list of Request-Tag options as belonging to the same operation.  </p>
<p id="rfc.section.3.2.p.2">To keep utilizing the cache, a server (including proxies) MAY discard the Request-Tag option from an assembled block-wise request when consulting its cache, as the option relates to the operation-on-the-wire and not its semantics.  For example, a FETCH request with the same body as an older one can be served from the cache if the older&#8217;s Max-Age has not expired yet, even if the second operation uses a Request-Tag and the first did not.  (This is similar to the situation about ETag in that it is formally part of the cache key, but implementations that are aware of its meaning can cache more efficiently, see <a href="#RFC7252" class="xref">[RFC7252]</a> Section 5.4.2).</p>
<p id="rfc.section.3.2.p.3">A server receiving a Request-Tag MUST treat it as opaque and make no assumptions about its content or structure.</p>
<p id="rfc.section.3.2.p.4">Two messages carrying the same Request-Tag is a necessary but not sufficient condition for being part of the same operation.  They can still be treated as independent messages by the server (e.g. when it sends 2.01/2.04 responses for every block), or initiate a new operation (overwriting kept context) when the later message carries Block1 number 0.</p>
<p id="rfc.section.3.2.p.5">As it has always been, a server that can only serve a limited number of block-wise operations at the same time can delay the start of the operation by replying with 5.03 (Service unavailable) and a Max-Age indicating how long it expects the existing operation to go on, or it can forget about the state established with the older operation and respond with 4.08 (Request Entity Incomplete) to later blocks on the first operation.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#setting-the-request-tag" id="setting-the-request-tag">Setting the Request-Tag</a>
</h1>
<p id="rfc.section.3.3.p.1">For each separate blockwise request operation, the client can choose a Request-Tag value, or choose not to set a Request-Tag.  Starting a request operation matchable to a previous operation and even using the same Request-Tag value is called request tag recycling.  The absence of a Request-Tag option is viewed as a value distinct from all values with a single Request-Tag option set; starting a request operation matchable to a previous operation where neither has a Request-Tag option therefore constitutes request tag recycling just as well (also called &#8220;recycling the absent option&#8221;).</p>
<p id="rfc.section.3.3.p.2">Clients MUST NOT recycle a request tag unless the first operation has concluded.  What constitutes a concluded operation depends on the application, and is outlined individually in <a href="#req-tag-applications" class="xref">Section 3.4</a>.</p>
<p id="rfc.section.3.3.p.3">When Block1 and Block2 are combined in an operation, the Request-Tag of the Block1 phase is set in the Block2 phase as well for otherwise the request would have a different set of options and would not be recognized any more.</p>
<p id="rfc.section.3.3.p.4">Clients are encouraged to generate compact messages. This means sending messages without Request-Tag options whenever possible, and using short values when the absent option can not be recycled.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#req-tag-applications" id="req-tag-applications">Applications</a>
</h1>
<h1 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#body-integrity" id="body-integrity">Body Integrity Based on Payload Integrity</a>
</h1>
<p id="rfc.section.3.4.1.p.1">When a client fragments a request body into multiple message payloads, even if the individual messages are integrity protected, it is still possible for a man-in-the-middle to maliciously replace a later operation&#8217;s blocks with an earlier operation&#8217;s blocks (see Section 2.5 of <a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a>). Therefore, the integrity protection of each block does not extend to the operation&#8217;s request body.</p>
<p id="rfc.section.3.4.1.p.2">In order to gain that protection, use the Request-Tag mechanism as follows:</p>
<p></p>

<ul>
<li>The individual exchanges MUST be integrity protected end-to-end between client and server.</li>
<li>The client MUST NOT recycle a request tag in a new operation unless the  previous operation matchable to the new one has concluded.  <br><br> If any future security mechanisms allow a block-wise transfer to continue after an endpoint&#8217;s details (like the IP address) have changed, then the client MUST consider messages sent to <em>any</em> endpoint address within the new operation&#8217;s security context.</li>
<li>The client MUST NOT regard a blockwise request operation as concluded unless all of the messages the client previously sent in the operation have been confirmed by the message integrity protection mechanism, or are considered invalid by the server if replayed.  <br><br> Typically, in OSCORE, these confirmations can result either from the client receiving an OSCORE response message matching the request (an empty ACK is insufficient), or because the message&#8217;s sequence number is old enough to be outside the server&#8217;s receive window.  <br><br> In DTLS, this can only be confirmed if the request message was not retransmitted, and was responded to.</li>
</ul>
<p id="rfc.section.3.4.1.p.4">Authors of other documents (e.g. <a href="#I-D.ietf-core-object-security" class="xref">[I-D.ietf-core-object-security]</a>) are invited to mandate this behavior for clients that execute blockwise interactions over secured transports. In this way, the server can rely on a conforming client to set the Request-Tag option when required, and thereby conclude on the integrity of the assembled body.</p>
<p id="rfc.section.3.4.1.p.5">Note that this mechanism is implicitly implemented when the security layer guarantees ordered delivery (e.g. CoAP over TLS <a href="#RFC8323" class="xref">[RFC8323]</a>). This is because with each message, any earlier message can not be replayed any more, so the client never needs to set the Request-Tag option unless it wants to perform concurrent operations.</p>
<h1 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> <a href="#multiple-concurrent-blockwise-operations" id="multiple-concurrent-blockwise-operations">Multiple Concurrent Blockwise Operations</a>
</h1>
<p id="rfc.section.3.4.2.p.1">CoAP clients, especially CoAP proxies, may initiate a blockwise request operation to a resource, to which a previous one is already in progress, which the new request should not cancel.  A CoAP proxy would be in such a situation when it forwards operations with the same cache-key options but possibly different payloads.</p>
<p id="rfc.section.3.4.2.p.2">For those cases, Request-Tag is the proxy-safe elective option suggested in <a href="#RFC7959" class="xref">[RFC7959]</a> Section 2.4 last paragraph.</p>
<p id="rfc.section.3.4.2.p.3">When initializing a new blockwise operation, a client has to look at other active operations:</p>
<p></p>

<ul>
<li>If any of them is matchable to the new one, and the client neither wants to cancel the old one nor postpone the new one, it can pick a Request-Tag value that is not in use by the other matchable operations for the new operation.</li>
<li>Otherwise, it can start the new operation without setting the Request-Tag option on it.</li>
</ul>
<h1 id="rfc.section.3.4.3">
<a href="#rfc.section.3.4.3">3.4.3.</a> <a href="#simplified-block-wise-handling-for-constrained-proxies" id="simplified-block-wise-handling-for-constrained-proxies">Simplified Block-Wise Handling for Constrained Proxies</a>
</h1>
<p id="rfc.section.3.4.3.p.1">The Block options were defined to be unsafe to forward because a proxy that would forward blocks as plain messages would risk mixing up clients&#8217; requests.</p>
<p id="rfc.section.3.4.3.p.2">The Request-Tag option provides a very simple way for a proxy to keep them separate: if it appends a Request-Tag that is particular to the requesting endpoint to all request carrying any Block option, it does not need to keep track of any further block state.</p>
<p id="rfc.section.3.4.3.p.3">This is particularly useful to proxies that strive for stateless operation as described in <a href="#I-D.hartke-core-stateless" class="xref">[I-D.hartke-core-stateless]</a> Section 3.1.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#rationale-for-the-option-properties" id="rationale-for-the-option-properties">Rationale for the Option Properties</a>
</h1>
<p id="rfc.section.3.5.p.1">The Request-Tag option can be elective, because to servers unaware of the Request-Tag option, operations with differing request tags will not be matchable.</p>
<p id="rfc.section.3.5.p.2">The Request-Tag option can be safe to forward but part of the cache key, because to proxies unaware of the Request-Tag option will consider operations with differing request tags unmatchable but can still forward them.</p>
<p id="rfc.section.3.5.p.3">The Request-Tag option is repeatable because this easily allows stateless proxies to &#8220;chain&#8221; their origin address.  Were it a single option, they would need to employ some length/value scheme to avoid confusing requests without a Request-Tag option with requests that carry a zero-length request tag.</p>
<p id="rfc.section.3.5.p.4">In earlier versions of this draft, the Request-Tag option used to be critical and unsafe to forward.  That design was based on an erroneous understanding of which blocks could be composed according to <a href="#RFC7959" class="xref">[RFC7959]</a>.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#rationale-for-introducing-the-option" id="rationale-for-introducing-the-option">Rationale for Introducing the Option</a>
</h1>
<p id="rfc.section.3.6.p.1">An alternative that was considered to the Request-Tag option for coping with the problem of fragmented message body integrity (<a href="#body-integrity" class="xref">Section 3.4.1</a>) was to update <a href="#RFC7959" class="xref">[RFC7959]</a> to say that blocks could only be assembled if their fragments&#8217; order corresponded to the sequence numbers.</p>
<p id="rfc.section.3.6.p.2">That approach would have been difficult to roll out reliably on DTLS where many implementations do not expose sequence numbers, and would still not prevent attacks like in <a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a> Section 2.5.2.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#etag" id="etag">Block2 / ETag Processing</a>
</h1>
<p id="rfc.section.4.p.1">The same security properties as in <a href="#body-integrity" class="xref">Section 3.4.1</a> can be obtained for blockwise response operations.  The threat model here is not an attacker (because the response is made sure to belong to the current request by the security layer), but blocks in the client&#8217;s cache.</p>
<p id="rfc.section.4.p.2">Rules stating that response body reassembly is conditional on matching ETag values are already in place from Section 2.4 of <a href="#RFC7959" class="xref">[RFC7959]</a>.</p>
<p id="rfc.section.4.p.3">To gain equivalent protection to <a href="#body-integrity" class="xref">Section 3.4.1</a>, a server MUST use the Block2 option in conjunction with the ETag option (<a href="#RFC7252" class="xref">[RFC7252]</a>, Section&#160;5.10.6), and MUST NOT use the same ETag value for different representations of a resource.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#token" id="token">Token Processing</a>
</h1>
<p id="rfc.section.5.p.1">As described in <a href="#req-resp-bind" class="xref">Section 1.3</a>, the client must be able to verify that a response corresponds to a particular request. This section updates the Token processing in Section 5.3.1 of <a href="#RFC7252" class="xref">[RFC7252]</a> by adding the following text:</p>
<p id="rfc.section.5.p.2">When CoAP is used with a security protocol not providing bindings between requests and responses, the client MUST NOT reuse tokens until the traffic keys have been replaced. The easiest way to accomplish this is to implement the Token as a counter, this approach SHOULD be followed.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec-cons" id="sec-cons">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">The availability of a secure pseudorandom number generator and truly random seeds are essential for the security of the Echo option. If no true random number generator is available, a truly random seed must be provided from an external source.</p>
<p id="rfc.section.6.p.2">An Echo value with 64 (pseudo-)random bits gives the same theoretical security level against forgeries as a 64-bit MAC (as used in e.g. AES_128_CCM_8). In practice, forgery of an Echo option value is much harder as an attacker must also forge the MAC in the security protocol. The Echo option value MUST contain 32 (pseudo-)random bits that are not predictable for any other party than the server, and SHOULD contain 64 (pseudo-)random bits. A server MAY use different security levels for different uses cases (client aliveness, request freshness, state synchronization, network address reachability, etc.).</p>
<p id="rfc.section.6.p.3">The security provided by the Echo and Request-Tag options depends on the security protocol used. CoAP and HTTP proxies require (D)TLS to be terminated at the proxies. The proxies are therefore able to manipulate, inject, delete, or reorder options or packets. The security claims in such architectures only hold under the assumption that all intermediaries are fully trusted and have not been compromised.</p>
<p id="rfc.section.6.p.4">Servers MUST use a monotonic clock to generate timestamps and compute round-trip times. Use of non-monotonic clocks is not secure as the server will accept expired Echo option values if the clock is moved backward. The server will also reject fresh Echo option values if the clock is moved forward.</p>
<p id="rfc.section.6.p.5">Servers are not allowed to use wall clock time for timestamps, as wall clock time is not monotonic. Furthermore, an attacker may be able to affect the server&#8217;s wall clock time in various ways such as setting up a fake NTP server or broadcasting false time signals to radio-controlled clocks.</p>
<p id="rfc.section.6.p.6">Servers MAY use the time since reboot measured in some unit of time. Servers MAY reset the timer at certain times and MAY generate a random offset applied to all timestamps. When resetting the timer, the server MUST reject all Echo values that was created before the reset.</p>
<p id="rfc.section.6.p.7">Servers that use the List of Cached Random Values and Timestamps method described in <a href="#echo-state" class="xref">Appendix A</a> may be vulnerable to resource exhaustion attacks. One way to minimize state is to use the Integrity Protected Timestamp method described in <a href="#echo-state" class="xref">Appendix A</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#priv-cons" id="priv-cons">Privacy Considerations</a>
</h1>
<p id="rfc.section.7.p.1">Implementations SHOULD NOT put any privacy sensitive information in the Echo or Request-Tag option values. Unencrypted timestamps MAY reveal information about the server such as location or time since reboot. The use of wall clock time is not allowed (see <a href="#sec-cons" class="xref">Section 6</a>) and there also privacy reasons, e.g. it may reveal that the server will accept expired certificates. Timestamps MAY be used if Echo is encrypted between the client and the server, e.g. in the case of DTLS without proxies or when using OSCORE with an Inner Echo option.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document adds the following option numbers to the &#8220;CoAP Option Numbers&#8221; registry defined by <a href="#RFC7252" class="xref">[RFC7252]</a>:</p>
<div id="rfc.figure.4"></div>
<div id="iana-table"></div>
<pre>
+--------+-------------+-------------------+
| Number | Name        | Reference         |
+--------+-------------+-------------------+
| TBD1   | Echo        | [[this document]] |
|        |             |                   |
| TBD2   | Request-Tag | [[this document]] |
+--------+-------------+-------------------+
</pre>
<p class="figure">Figure 4: CoAP Option Numbers</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7252">[RFC7252]</b></td>
<td class="top">
<a>Shelby, Z.</a>, <a>Hartke, K.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/rfc7252">The Constrained Application Protocol (CoAP)</a>", RFC 7252, DOI 10.17487/RFC7252, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7959">[RFC7959]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>Z. Shelby</a>, "<a href="https://tools.ietf.org/html/rfc7959">Block-Wise Transfers in the Constrained Application Protocol (CoAP)</a>", RFC 7959, DOI 10.17487/RFC7959, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.hartke-core-stateless">[I-D.hartke-core-stateless]</b></td>
<td class="top">
<a>Hartke, K.</a>, "<a href="https://tools.ietf.org/html/draft-hartke-core-stateless-02">Extended Tokens and Stateless Clients in the Constrained Application Protocol (CoAP)</a>", Internet-Draft draft-hartke-core-stateless-02, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-object-security">[I-D.ietf-core-object-security]</b></td>
<td class="top">
<a>Selander, G.</a>, <a>Mattsson, J.</a>, <a>Palombini, F.</a> and <a>L. Seitz</a>, "<a href="https://tools.ietf.org/html/draft-ietf-core-object-security-15">Object Security for Constrained RESTful Environments (OSCORE)</a>", Internet-Draft draft-ietf-core-object-security-15, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-oscore-groupcomm">[I-D.ietf-core-oscore-groupcomm]</b></td>
<td class="top">
<a>Tiloca, M.</a>, <a>Selander, G.</a>, <a>Palombini, F.</a> and <a>J. Park</a>, "<a href="https://tools.ietf.org/html/draft-ietf-core-oscore-groupcomm-03">Group OSCORE - Secure Group Communication for CoAP</a>", Internet-Draft draft-ietf-core-oscore-groupcomm-03, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.mattsson-core-coap-actuators">[I-D.mattsson-core-coap-actuators]</b></td>
<td class="top">
<a>Mattsson, J.</a>, <a>Fornehed, J.</a>, <a>Selander, G.</a>, <a>Palombini, F.</a> and <a>C. Amsuess</a>, "<a href="https://tools.ietf.org/html/draft-mattsson-core-coap-actuators-06">Controlling Actuators with CoAP</a>", Internet-Draft draft-mattsson-core-coap-actuators-06, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6347">[RFC6347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7390">[RFC7390]</b></td>
<td class="top">
<a>Rahman, A.</a> and <a>E. Dijk</a>, "<a href="https://tools.ietf.org/html/rfc7390">Group Communication for the Constrained Application Protocol (CoAP)</a>", RFC 7390, DOI 10.17487/RFC7390, October 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7641">[RFC7641]</b></td>
<td class="top">
<a>Hartke, K.</a>, "<a href="https://tools.ietf.org/html/rfc7641">Observing Resources in the Constrained Application Protocol (CoAP)</a>", RFC 7641, DOI 10.17487/RFC7641, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8323">[RFC8323]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Lemay, S.</a>, <a>Tschofenig, H.</a>, <a>Hartke, K.</a>, <a>Silverajan, B.</a> and <a>B. Raymor</a>, "<a href="https://tools.ietf.org/html/rfc8323">CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets</a>", RFC 8323, DOI 10.17487/RFC8323, February 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#echo-state" id="echo-state">Methods for Generating Echo Option Values</a>
</h1>
<p id="rfc.section.A.p.1">The content and structure of the Echo option value are implementation specific and determined by the server. Two simple mechanisms are outlined in this section, the first is RECOMMENDED in general, and the second is RECOMMENDED in case the Echo option is encrypted between the client and the server.</p>
<p id="rfc.section.A.p.2">Different mechanisms have different tradeoffs between the size of the Echo option value, the amount of server state, the amount of computation, and the security properties offered. A server MAY use different methods and security levels for different uses cases (client aliveness, request freshness, state synchronization, network address reachability, etc.).</p>
<p id="rfc.section.A.p.3">1. List of Cached Random Values and Timestamps. The Echo option value is a (pseudo-)random byte string. The server caches a list containing the random byte strings and their transmission times. Assuming 72-bit random values and 32-bit timestamps, the size of the Echo option value is 9 bytes and the amount of server state is 13n bytes, where n is the number of active Echo Option values. The security against forged echo values is given by s = bit length of r - log2(n). The length of r and the maximum allowed n should be set so that the security level is harmonized with other parts of the deployment, e.g. s &gt;= 64. If the server loses time continuity, e.g. due to reboot, the entries in the old list MUST be deleted.</p>
<pre>
      Echo option value: random value r
      Server State: random value r, timestamp t0
</pre>
<p id="rfc.section.A.p.4">2. Integrity Protected Timestamp. The Echo option value is an integrity protected timestamp. The timestamp can have different resolution and range. A 32-bit timestamp can e.g. give a resolution of 1 second with a range of 136 years. The (pseudo-)random secret key is generated by the server and not shared with any other party. The use of truncated HMAC-SHA-256 is RECOMMENDED. With a 32-bit timestamp and a 64-bit MAC, the size of the Echo option value is 12 bytes and the Server state is small and constant. The security against forged echo values is given by the MAC length. If the server loses time continuity, e.g. due to reboot, the old key MUST be deleted and replaced by a new random secret key. Note that the privacy considerations in <a href="#priv-cons" class="xref">Section 7</a> may apply to the timestamp. A server MAY want to encrypt its timestamps, and, depending on the choice of encryption algorithms, this may require a nonce to be included in the Echo option value.</p>
<pre>
      Echo option value: timestamp t0, MAC(k, t0)
      Server State: secret key k
</pre>
<p id="rfc.section.A.p.5">Other mechanisms complying with the security and privacy considerations may be used. The use of encrypted timestamps in the Echo option typically requires an IV to be included in the Echo option value, which adds overhead and makes the specification of such a mechanims slightly more complicated than the two mechanisms specified here.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#request-tag-message-size-impact" id="request-tag-message-size-impact">Request-Tag Message Size Impact</a>
</h1>
<p id="rfc.section.B.p.1">In absence of concurrent operations, the Request-Tag mechanism for body integrity (<a href="#body-integrity" class="xref">Section 3.4.1</a>) incurs no overhead if no messages are lost (more precisely: in OSCORE, if no operations are aborted due to repeated transmission failure; in DTLS, if no packages are lost), or when blockwise request operations happen rarely (in OSCORE, if there is always only one request blockwise operation in the replay window).</p>
<p id="rfc.section.B.p.2">In those situations, no message has any Request-Tag option set, and that can be recycled indefinitely.</p>
<p id="rfc.section.B.p.3">When the absence of a Request-Tag option can not be recycled any more within a security context, the messages with a present but empty Request-Tag option can be used (1 Byte overhead), and when that is used-up, 256 values from one byte long options (2 Bytes overhead) are available.</p>
<p id="rfc.section.B.p.4">In situations where those overheads are unacceptable (e.g. because the payloads are known to be at a fragmentation threshold), the absent Request-Tag value can be made usable again:</p>
<p></p>

<ul>
<li>In DTLS, a new session can be established.</li>
<li>In OSCORE, the sequence number can be artificially increased so that all lost messages are outside of the replay window by the time the first request of the new operation gets processed, and all earlier operations can therefore be regarded as concluded.</li>
</ul>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p id="rfc.section.C.p.1">[ The editor is asked to remove this section before publication. ]</p>
<p></p>

<ul>
<li>Major changes since draft-ietf-core-echo-request-tag-01:  <ul>
<li>Follow-up changes after the &#8220;relying on blockwise&#8221; change in -01:      <ul>
<li>Simplify the description of Request-Tag and matchability</li>
<li>Do not update RFC7959 any more</li>
</ul>
</li>
<li>Make Request-Tag repeatable.</li>
<li>Add rationale on not relying purely on sequence numbers.</li>
</ul>
</li>
<li>Major changes since draft-ietf-core-echo-request-tag-00: <ul>
<li>Reworded the Echo section.</li>
<li>Added rules for Token processing.</li>
<li>Added security considerations.</li>
<li>Added actual IANA section.</li>
<li>Made Request-Tag optional and safe-to-forward, relying on blockwise to treat it as part of the cache-key</li>
<li>Dropped use case about OSCORE outer-blockwise (the case went away when its Partial IV was moved into the Object-Security option)</li>
</ul>
</li>
<li>Major changes since draft-amsuess-core-repeat-request-tag-00: <ul>
<li>The option used for establishing freshness was renamed from &#8220;Repeat&#8221; to &#8220;Echo&#8221; to reduce confusion about repeatable options.</li>
<li>The response code that goes with Echo was changed from 4.03 to 4.01 because the client needs to provide better credentials.</li>
<li>The interaction between the new option and (cross) proxies is now covered.</li>
<li>Two messages being &#8220;Request-Tag matchable&#8221; was introduced to replace the older concept of having a request tag value with its slightly awkward equivalence definition.</li>
</ul>
</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.D.p.1">The authors want to thank Jim Schaad for providing valuable input to the draft.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Ams&#252;ss</span> 
	  <span class="n hidden">
		<span class="family-name">Amsuess</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christian@amsuess.com">christian@amsuess.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Mattsson</span> 
	  <span class="n hidden">
		<span class="family-name">Mattsson</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:john.mattsson@ericsson.com">john.mattsson@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">G&#246;ran Selander</span> 
	  <span class="n hidden">
		<span class="family-name">Selander</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goran.selander@ericsson.com">goran.selander@ericsson.com</a></span>

  </address>
</div>

</body>
</html>
